#!/bin/bash
#

function print_netif_info {
[ "" == "$1" ] && return 1
local p=$1
local d=$(readlink -f $p)
cat <<__EOF__
$(basename $p)
$(cat $d/ifindex)
$(($(cat $d/flags) & 0x01))
$(($(cat $d/flags) & 0x02))
$(cat $d/flags)
$(cat $d/address)
$(basename $(dirname $(dirname $d)))
$p
$d
__EOF__
}

function net_detect_interfaces {
	local OUTPUT_FILE=$1
	local TMP_FILE=$(mktemp /tmp/XXXXXX)
	INFO "detecting network interfaces ..."
	for n in $(find ${NET_SYS_CLASS_PATH} -maxdepth 1 -mindepth 1); do
		echo "$(print_netif_info $n | tr '\n' ' ')" >> ${TMP_FILE}
	done
	cat ${TMP_FILE} | sort -n -k2 | grep -v virtual > ${OUTPUT_FILE}
	rm -f ${TMP_FILE}
	INFO "found network interfaces: $(LIGHT_GREEN $(cat ${OUTPUT_FILE} | awk '{print $1}' | tr '\n' ' '))"
	cat ${OUTPUT_FILE} | awk '{printf "\t%s\n", $0}' | tr ' ' '\t'
}

function net_get_profile_conf {
	local NAME=$1
	local DEFAULT=$2
	local INFO=$3 # optional
	[ "" == "${NAME}" ] && return 0
	[ "" == "${DEFAULT}" ] && return 0
	local VALUE=$(call_profile_hook get_net_conf ${NAME} ${DEFAULT} ${INFO} 2>/dev/null)
	[ "0" != "$?" ] && echo "${DEFAULT}" && return 0
	[ "" == "${VALUE}" ] && echo "${DEFAULT}" && return 0
	echo "${VALUE}"
}

function net_bring_up_interface {
	local COUNTER="5"
	local NETIF=$1
	[ "" == "${NETIF}" ] && INFO "no interface to be brought up" && return 1
	local FILE="${NET_SYS_CLASS_PATH}/${NETIF}/flags"
	[ ! -f "${FILE}" ] && INFO "flag file ${FILE} does not exist" && return 1
	local UP=$(($(cat ${FILE}) & 0x01))

	if [ "1" == "${UP}" ]; then
		INFO "$(YELLOW ${NETIF}) has been brought up (interface-up)"
		return 0
	else
		RUN_CMD_STREAMING "ip link set ${NETIF} up"
		while true; do
			UP=$(($(cat ${FILE}) & 0x01))
			INFO "waiting for $(YELLOW ${NETIF}) up... $(PURPLE ${COUNTER})s (flags = $(LIGHT_GREEN $(cat ${FILE})), up = ${UP})"
			[ "1" == "${UP}" ] && break
			[ "$COUNTER" -lt "1" ] && INFO "waiting for $(YELLOW ${NETIF}) up ... timeout!!" && return 1
			COUNTER=$(($COUNTER-1))
			sleep 1
		done
		INFO "$(YELLOW ${NETIF}) is brought up (interface-up)"
	fi
}

function net_dailup_wireless_data_link {
	local NETIF=$1
	return 0
}

function net_dailup_ethernet_data_link {
	local NETIF=$2
	return 0
}

function net_dailup_data_link {
	local COUNTER=5
	local NETIF=$1
	local DAILUP=$2
	[ "" == "${NETIF}" ] && INFO "no interface to be dailed up" && return 1
	[ "" == "${DAILUP}" ] && INFO "no dail up function for ${NETIF}" && return 1
	local FILE="${NET_SYS_CLASS_PATH}/${NETIF}/carrier"

	${DAILUP} ${NETIF}
	local EXIT_CODE=$?
	[ "0" != "${EXIT_CODE}" ] && INFO "failed to perform dail up for ${NETIF} with ${DAILUP}(), exit: ${EXIT_CODE}" && return 1

	local CARRIER=$(cat ${FILE})
	if [ "1" == "${CARRIER}" ]; then
		INFO "$(YELLOW ${NETIF}) data link layer is ready (data-link-dailup)"
	else
		while true; do
			local CARRIER=$(cat ${FILE})
			INFO "waiting for $(YELLOW ${NETIF}) carrier ready... $(PURPLE ${COUNTER})s (carrier = $(LIGHT_GREEN ${CARRIER}))"
			[ "1" == "${CARRIER}" ] && break
			[ "$COUNTER" -lt "1" ] && INFO "waiting for $(YELLOW ${NETIF}) carrier ... timeout!!" && return 1
			COUNTER=$(($COUNTER-1))
			sleep 1
		done
	fi
	return 0
}

function initialize_network {
	export NET_INTERFACES_FILE="/tmp/interfaces.txt"
	export NET_SYS_CLASS_PATH="/sys/class/net"
	net_detect_interfaces ${NET_INTERFACES_FILE}

	local DEFAULT_INTERFACES=$(cat ${NET_INTERFACES_FILE} | awk '{print $1}' | tr '\n' ',' | sed 's/,$//g')
	local PREFERRED_INTERFACES=$(net_get_profile_conf "preferred_interfaces" ${DEFAULT_INTERFACES} ${NET_INTERFACES_FILE})
	
	INFO "detected interfaces: ${DEFAULT_INTERFACES}"
	INFO "preferred interfaces: $(echo ${PREFERRED_INTERFACES} | tr ',' ' ')"

	local XS=($(echo ${PREFERRED_INTERFACES} | tr ',' '\n'))

	for interface in "${XS[@]}"; do
		local INFO=$(cat ${NET_INTERFACES_FILE} | grep "^${interface}")
		[ "" == "${INFO}" ] && INFO "ignore ${interface} because it is missing in ${NET_INTERFACES_FILE}" && continue

		case "${interface}" in
			eth*)
				local DAILUP="net_dailup_ethernet_data_link"
				;;
			wlan*)
				local DAILUP="net_dailup_wireless_data_link"
				;;
			ppp*)
				INFO "ppp dialup is unsupported: ${interface}"
				continue
				;;
			usb*)
				INFO "usb dialup is unsupported: ${interface}"
				continue
				;;
			*)
				INFO "unknown network interface ${interface}, and no idea how to dial up"
				continue
				;;
		esac

		net_bring_up_interface ${interface} &&
			net_dailup_data_link ${interface} ${DAILUP}
	done
}
