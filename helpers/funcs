#!/bin/bash

function init-yac-variables {
	TMP=$(pwd)
	cd $(dirname $0)
	cd ../
	export YAC_DIR=$(pwd)
	export YAC_BIN_DIR="${YAC_DIR}/bin"
	export YAC_LIB_DIR="${YAC_DIR}/helpers"
	cd ${TMP}

	[ "" == "${YS_DIR}" ] && export YS_DIR=$(cat /etc/environment | grep "^YS_DIR" | awk -F'=' '{print $2}')
	[ "" == "${BOARD_PROFILE}" ] && export BOARD_PROFILE=$(cat /etc/environment | grep "^BOARD_PROFILE" | awk -F'=' '{print $2}')
	[ "" == "${BOARD_BASE_VERSION}" ] && export BOARD_BASE_VERSION=$(cat /etc/environment | grep "^BOARD_BASE_VERSION" | awk -F'=' '{print $2}')
	[ "" == "${BOARD_BASE_VERSION}" ] && BOARD_BASE_VERSION="99991231z"

	[ -f "/mnt/app/profiles/${BOARD_PROFILE}/env" ] || {
		echo "production" > /mnt/app/profiles/${BOARD_PROFILE}/env
	}
	cat /mnt/app/profiles/${BOARD_PROFILE}/env > /mnt/app/profiles/${BOARD_PROFILE}/env.old
	export BOARD_PROFILE_ENV=$(cat /mnt/app/profiles/${BOARD_PROFILE}/env)
	export BOARD_PROFILE_VERSION=$(cat /mnt/app/profiles/${BOARD_PROFILE}/entry)

	export PROFILE_ROOT="/${BOARD_PROFILE}"
	export PROFILE_LOG_DIR="${PROFILE_ROOT}/logs"
	export PROFILE_LOG_SYS_DIR="${PROFILE_LOG_DIR}/system"
	export PROFILE_LOG_APP_DIR="${PROFILE_LOG_DIR}/app"
	export PROFILE_STORAGE_DIR="${PROFILE_ROOT}/storage"

	export PROFILE_CURRENT_DIR="${PROFILE_ROOT}/current"
	export PROFILE_CURRENT_LOG_DIR="${PROFILE_CURRENT_DIR}/logs"

	[ "" == "${NODEJS_VERSION}" ] && export NODEJS_VERSION=$(cat ${YS_DIR}/defaults.conf | grep "^nodejs" | awk -F'\t' '{print $2}')
	[ "" == "${PYTHON_VERSION}" ] && export PYTHON_VERSION=$(cat ${YS_DIR}/defaults.conf | grep "^python" | awk -F'\t' '{print $2}')
	local CLOUD_BASHRC="/tmp/cloud.bashrc"
	[ -f "${CLOUD_BASHRC}" ] || {
		#
		# Initialize following environment variables from cloud.bashrc:
		#   - ARCHIVE_URL
		#   - RELEASE_URL
		#   - RELEASE_USER
		#   - RELEASE_PASS
		#   - FILE_FC
		#   - FILE_SITE
		#   - FILE_USER
		#   - FILE_PSWD
		#
		mkdir -p $(dirname ${CLOUD_BASHRC})
		cat ${YS_DIR}/cloud.conf | awk '{printf "export CLOUD_%s=%s\n", $1, $2}' > ${CLOUD_BASHRC}
	}
	source ${CLOUD_BASHRC}

	export RUNTIME_DIR="/mnt/app/runtimes"

	if [ "default" == "${NODEJS_VERSION}" ]; then
		# When using system default nodejs pacakge, then 
		# using `nodenv` to get the version and path of installed
		# nodejs package.
		#
		# If `nodenv` is not setup yet, needs to activate 
		# /opt/dotfiles/.bashrc
		#
		[ "" == "${HOME}" ] && export HOME=/root && INFO ""
		[ "" == "${NODENV_SHELL}" ] && export PATH="/root/.nodenv/bin:$PATH" && eval "$(nodenv init -)"
		[ "" == "${NODENV_SHELL}" ] && INFO "missing nodenv!!" && exit 1
		local VERSION=$(nodenv version | awk '{print $1}')
		local NODEDIR=$(dirname $(nodenv which node))
		DBG "[default] nodejs.version = $(LIGHT_GREEN ${VERSION})"
		DBG "[default] nodejs.path = $(LIGHT_GREEN ${NODEDIR})"
		cd ${NODEDIR} && cd ..
		export RUNTIME_NODEJS_DIR=$(pwd)
		export NODEJS_VERSION=${VERSION}
		cd ${TMP}
	else
		[ "" == "${RUNTIME_NODEJS_DIR}" ] && export RUNTIME_NODEJS_DIR="${RUNTIME_DIR}/nodejs/${NODEJS_VERSION}"
	fi

	export RUNTIME_DIR="/mnt/app/runtimes"
	[ "" == "${RUNTIME_PYTHON_DIR}" ] && export RUNTIME_PYTHON_DIR="${RUNTIME_DIR}/python/${PYTHON_VERSION}"

	export NODEJS_MODULE_DIR="${PROFILE_CURRENT_DIR}/runtimes/nodejs/${NODEJS_VERSION}"
}


function download_nodejs_modules {
	local CURRENT=$(pwd)
	local VERSION=$1
	local CURRENT_OS_NAME=$2
	local CURRENT_OS_ARCH=$3
	local MODULE_DIR=$4
	local MODULE_CONF=$5
	local SERVER_URL=$6
	local SERVER_DIR="/embedded-linux/nodejs-modules/${CURRENT_OS_NAME}/${CURRENT_OS_ARCH}/${VERSION}"
	local ARCHIVE_LIST_FILE="/tmp/archives.txt"

	[ -d ${MODULE_DIR}/node_modules ] && return 0 || mkdir -p ${MODULE_DIR}
	[ ! -f ${MODULE_CONF} ] && INFO "missing ${MODULE_CONF}" && return 1
	local MODULES=$(cat ${MODULE_CONF} | tr '\t' '@' | tr '\n' ' ')
	local MODULES_X=$(echo ${MODULES} | sed 's/\ $//g' | tr ' ' ':')

	INFO "installing $(PURPLE ${MODULES}) for $(LIGHT_GREEN ${CURRENT_OS_NAME})/$(LIGHT_GREEN ${CURRENT_OS_ARCH}) ..."

	INFO "checking module archives cached at cloud: ${SERVER_URL}${SERVER_DIR}/$(basename ${ARCHIVE_LIST_FILE})"
	http --check-status --ignore-stdin ${SERVER_URL}${SERVER_DIR}/$(basename ${ARCHIVE_LIST_FILE}) > ${ARCHIVE_LIST_FILE}
	[ "0" != "$?" ] && INFO "failed to download archives.txt from ${SERVER_URL}${SERVER_DIR}/$(basename ${ARCHIVE_LIST_FILE})" && return 1

	local UUID=$(cat ${ARCHIVE_LIST_FILE} | grep ${MODULES_X} | awk -F'\t' '{print $1}' | tail -n1)
	local UUID_GZIP_FILE="${UUID}.tar.gz"
	local GZIPPED_FILE="/tmp/${UUID_GZIP_FILE}"
	rm -f ${ARCHIVE_LIST_FILE}
	[ "" == "${UUID}" ] && INFO "no matching modules" && return 1

	INFO "downloading modules from cloud: $(LIGHT_GREEN ${UUID_GZIP_FILE})"
	http --check-status --ignore-stdin "${SERVER_URL}${SERVER_DIR}/${UUID_GZIP_FILE}" > ${GZIPPED_FILE}
	[ "0" != "$?" ] && INFO "failed to download ${UUID_GZIP_FILE} from ${SERVER_URL}${SERVER_DIR}/${UUID_GZIP_FILE}" && return 1

	INFO "decompressing the downloaded module gzip file: ${GZIPPED_FILE}"
	tar xf ${GZIPPED_FILE} -C ${MODULE_DIR}
	[ "0" != "$?" ] && INFO "failed to uncompress ${GZIPPED_FILE}" && rm -f ${GZIPPED_FILE} && return 1
	INFO "use downloaded module archive"
	rm -f ${GZIPPED_FILE}
}

function function_exist {
	declare -f -F $1 > /dev/null
	return $?
}

function call_func {
	local FUNC=$1
	shift
	function_exist ${FUNC} && ${FUNC} $@
}
