#!/bin/bash
#
##DOC:	bootup yac system, including initiate wireless and generate /tmp/ttt_system

function check_prerequisites {
	check_tool_prerequisites ifconfig iwlist
}

function initiate_extra_ethernet_interfaces {
	[ "true" == "${YAPPS_SYS_INITIATE_EXTRA_ETHERNET_IFS}" ] || return
	local INTERFACES=($(find /sys/class/net -maxdepth 1 -mindepth 1 | grep "/sys/class/net/eth" | grep -v "/sys/class/net/eth0"))
	for eth in "${INTERFACES[@]}" ; do
		local DEVICE=$(basename ${eth})
		INFO "renew dhcp $(YELLOW ${DEVICE})"
		dhclient ${DEVICE} && INFO "${DEVICE} => $(LIGHT_GREEN $(/sbin/ip -o -4 addr list ${DEVICE} | awk '{print $4}' | cut -d/ -f1))"
	done
}

function mount_directories {
	mkdir -p ${PROFILE_LOG_DIR}
	mkdir -p ${PROFILE_STORAGE_DIR}
	mkdir -p ${PROFILE_CURRENT_DIR}
	if [ "" == "$(mount | grep ${PROFILE_LOG_DIR})" ]; then
		mkdir -p /mnt/data/profiles/${BOARD_PROFILE}/logs
		mount -o bind /mnt/data/profiles/${BOARD_PROFILE}/logs ${PROFILE_LOG_DIR}
		INFO "mount $(LIGHT_GREEN ${PROFILE_LOG_DIR})"
		mkdir -p ${PROFILE_LOG_SYS_DIR}
		mkdir -p ${PROFILE_LOG_APP_DIR}
	fi

	if [ "" == "$(mount | grep ${PROFILE_STORAGE_DIR})" ]; then
		mkdir -p /mnt/data/profiles/${BOARD_PROFILE}/storage
		mount -o bind /mnt/data/profiles/${BOARD_PROFILE}/storage ${PROFILE_STORAGE_DIR}
		INFO "mount $(LIGHT_GREEN ${PROFILE_STORAGE_DIR})"
	fi

	if [ "" == "$(mount | grep ${PROFILE_CURRENT_DIR})" ]; then
		mount -o bind /mnt/app/profiles/${BOARD_PROFILE}/${BOARD_PROFILE_VERSION} ${PROFILE_CURRENT_DIR}
		INFO "mount $(LIGHT_GREEN ${PROFILE_CURRENT_DIR})"
		mkdir -p ${PROFILE_CURRENT_LOG_DIR}
	fi
}

function load_hooks {
	local BOARD_SYS_HOOK="${YS_DIR}/etc/.yac"
	local PROFILE_SYS_HOOK="${PROFILE_CURRENT_DIR}/etc/.yac"
	[ -f "${BOARD_SYS_HOOK}" ] && source ${BOARD_SYS_HOOK} && INFO "source $(LIGHT_GREEN ${BOARD_SYS_HOOK})"
	[ -f "${PROFILE_SYS_HOOK}" ] && source ${PROFILE_SYS_HOOK} && INFO "source $(LIGHT_GREEN ${PROFILE_SYS_HOOK})"
}

function output {
	echo $@
}

function check_connectivity {
	[ "" == "${WIRELESS_IF}" ] && local WIRELESS_IF=$1
	[ "" == "${WIRELESS_IF}" ] && output "91" && return

	# Check the connectivity of data-link layer in OSI (to wireless access-point).
	#
	local AP_MAC=$(iwconfig ${WIRELESS_IF} | head -n2 | tail -n1 | tr ' ' '\n' | grep -v '^$' | tail -n1)
	[ "Not-Associated" == "${AP_MAC}" ] && output "92" && return
	[ "" == "${AP_MAC}" ] && output "93" && return

	# Check the LAN connectivity of network/ip layer in OSI (ping to default gateway).
	#
	local GATEWAY=$(route -n | grep " UG " | awk '{print $2}')
	[ "" == "${GATEWAY}" ] && output "94" && return
	ping -c 1 ${GATEWAY} > /dev/null 2>&1
	[ "0" != "$?" ] && output "95" && return

	# Check the WAN connectivity of network/ip layer in OSI (ping to 8.8.8.8).
	#
	ping -c 1 -W 5 8.8.8.8 > /dev/null 2>&1
	[ "0" != "$?" ] && output "96" && return

	# Check the health of transport layer in OSI (dns lookup)
	#
	echo -e 'server 8.8.8.8\nset timeout=2\nwww.google.com' | nslookup > /dev/null 2>&1
	[ "0" != "$?" ] && output "97" && return

	output "99"
}

function wait_internet_connection {
	local TIMES=0
	local MAX_RETRIES=$(call_func "yac_hook" "get_wait_internet_retries")
	local RETRY_DELAY=$(call_func "yac_hook" "get_wait_internet_retry_delay")
	[ "" == "${MAX_RETRIES}" ] && MAX_RETRIES="7"
	[ "" == "${RETRY_DELAY}" ] && RETRY_DELAY="0"

	local CONNECTIVITY="$(check_connectivity)"
	[ "99" == "${CONNECTIVITY}" ] && INFO "connectivity => 99, no need to wait"

	while [ "99" != "${CONNECTIVITY}" ]; do
		notify_event "wait_internet" ${TIMES}
		TIMES=$(($TIMES+1))
		[ "${TIMES}" -gt ${MAX_RETRIES} ] && INFO "connectivity => ${CONNECTIVITY} (not good but timeout)" && break
		if [ "0" == "${RETRY_DELAY}" ]; then
			INFO "connectivity => ${CONNECTIVITY}, not good"
		else
			INFO "connectivity => ${CONNECTIVITY}, not good, wait for ${RETRY_DELAY} second and retry"
			sleep ${RETRY_DELAY}
		fi
		CONNECTIVITY="$(check_connectivity)"
	done

	export WIRELESS_CONNECTIVITY=${CONNECTIVITY}
}

function bootup_wireless_adapter {
	# Search the WLAN device, might be wlan0, or wlan1, ...
	#
	INFO "detecting wireless adapter ..."
	export WIRELESS_IF=$(ifconfig -a | grep wlan | awk '{print $1}')
	[ "" ==  "${WIRELESS_IF}" ] && ERR "no available wireless interface" && return
	INFO "wireless device is $(YELLOW ${WIRELESS_IF})"

	if [ "" == "$(ifconfig ${WIRELESS_IF} | grep UP)" ]; then
		INFO "bring $(YELLOW ${WIRELESS_IF}) up"
		ifconfig ${WIRELESS_IF} up
		INFO "result = $?"
	fi
}

function find_ap_and_connect {
	# Scan current environment with all available wireless access points
	#
	[ "" ==  "${WIRELESS_IF}" ] && return
	export AP_LIST=$(mktemp /tmp/XXXXXX)
	iwlist ${WIRELESS_IF} scanning | bash ${YAC_LIB_DIR}/parse_iwlist_scan | sort -u > ${AP_LIST}
	INFO "found access-points: $(BLUE $(cat ${AP_LIST} | tr '\n' ' '))"

	# Read system settings for wireless
	#
	local TMP2=$(mktemp /tmp/XXXXXX)
	local TMP3=$(mktemp /tmp/XXXXXX)
	local TMP4=$(mktemp /tmp/XXXXXX)
	local PROFILE_WPA_CONF="${YS_DIR}/profiles/${BOARD_PROFILE}/wpa.config"

	[ "" == "${WIRELESS_KEYSTORES}" ] && WIRELESS_KEYSTORES="${YS_DIR}/wireless-keystores.conf"
	[ ! -f "${WIRELESS_KEYSTORES}" ] && WIRELESS_KEYSTORES="${YS_DIR}/wireless-keystores.conf"
	local PROFILE_WIRELESS_KEYSTORES="${YS_DIR}/profiles/${BOARD_PROFILE}/wireless-keystores.conf"
	if [ -f "${PROFILE_WIRELESS_KEYSTORES}" ]; then
		cat ${PROFILE_WIRELESS_KEYSTORES} | sed -e 's/^ *//' | sed -e 's/ *$//' | sed 's/#.*$//g' | grep -v "^$" | nl -nrz -w9 > ${TMP2}
	fi
	if [ -f "${WIRELESS_KEYSTORES}" ]; then
		cat ${WIRELESS_KEYSTORES} | sed -e 's/^ *//' | sed -e 's/ *$//' | sed 's/#.*$//g' | grep -v "^$" | nl -nrz -w9 >> ${TMP2}
	fi
	cat ${AP_LIST} | tr '\n' '\0' | xargs -0 -I{} sh -c "grep -P \"^.........\t{}\t\" ${TMP2}" >> ${TMP3}
	[ -f "${PROFILE_WPA_CONF}" ] && echo ${PROFILE_WPA_CONF} > ${TMP4}
	sort ${TMP3} | awk -F '\t' '{printf "%s\t%s\n", $2, $3}' >> ${TMP4}
	INFO "try access-points: $(BLUE $(cat ${TMP4} | awk -F '\t' '{print $1}' | tr '\n' ' '))"

	local WIFI_LOGFILE="${PROFILE_LOG_SYS_DIR}/wireless_`date +%Y_%m%d_%H%M`.log"
	IFS=$' \n'
	local SETTINGS=($(cat ${TMP4}))
	unset IFS

	rm -f ${TMP2}
	rm -f ${TMP3}
	rm -f ${TMP4}
	rm -f ${AP_LIST}

	export WIRELESS_CONNECTED="false"
	export WIRELESS_CONNECTIVITY="0"
	source ${YAC_LIB_DIR}/wireless_connect

	# Try to connect wireless access point one-by-one
	#
	for s in "${SETTINGS[@]}" ; do
		local SSID=$(echo $s | awk '{print $1}')
		local PASS=$(echo $s | awk '{print $2}')
		local TMP5=$(mktemp /tmp/XXXXXX)
		notify_event "find_ap_and_connect" ${WIRELESS_IF} ${SSID} ${PASS}
		if [ "${SSID}" == "${PROFILE_WPA_CONF}" ]; then
			INFO "connecting to wireless access-point with wpa config $(YELLOW ${PROFILE_WPA_CONF})"
			WIRELESS_IF=${WIRELESS_IF} WIFI_LOGFILE=${WIFI_LOGFILE} WAITING_TIME_LOGFILE=${TMP5} connect_to_ap_with_conf ${PROFILE_WPA_CONF}
			INFO "connect_to_ap_with_conf returns $?"
		else
			INFO "connecting to $(YELLOW ${SSID}) with password $(YELLOW ${PASS})"
			WIRELESS_IF=${WIRELESS_IF} WIFI_LOGFILE=${WIFI_LOGFILE} WAITING_TIME_LOGFILE=${TMP5} connect_to_ap ${SSID} ${PASS}
			INFO "connect_to_ap returns $?"
		fi

		export WIRELESS_AP_MAC=$(iwconfig ${WIRELESS_IF} | grep 'Access Point' | sed 's/.*Access Point: //g')
		export WIRELESS_IP_ADDR=$(ifconfig ${WIRELESS_IF} | grep "inet addr" | awk '{print $2}' | sed 's/addr://g')
		if [ "" == "$(echo ${WIRELESS_AP_MAC} | grep ':')" ] || [ "" == "${WIRELESS_IP_ADDR}" ]; then
			sleep 1
			rm -f ${TMP5}
		else
			export WIRELESS_CONNECTED="true"
			INFO "wireless-ap-mac = $(LIGHT_GREEN ${WIRELESS_AP_MAC})"
			INFO "wireless-ip = $(LIGHT_GREEN ${WIRELESS_IP_ADDR})"
			INFO "spent $(cat ${TMP5}) seconds to connect to wireless ap"
			export SSID
			export WIRELESS_CONNECTING_TIME=$(cat ${TMP5})
			rm -f ${TMP5}
			rm -f ${PROFILE_CURRENT_LOG_DIR}/wireless.log
			ln -s ${WIFI_LOGFILE} ${PROFILE_CURRENT_LOG_DIR}/wireless.log
			INFO "log: $(BLUE ${PROFILE_CURRENT_LOG_DIR}/wireless.log) -> ${WIFI_LOGFILE}"
			wait_internet_connection
			break
		fi
	done
}

function generate_ttt_system {
cat << __EOF__ > /tmp/ttt_system
id	${BOARD_UNIQUE_ID}
sn	${BOARD_SERIAL_NUMBER}
alias	${BOARD_NAME}
base_version	${BOARD_BASE_VERSION}
profile	${BOARD_PROFILE}
profile_version	${BOARD_PROFILE_VERSION}
profile_env	${BOARD_PROFILE_ENV}
wireless_ap_mac	${WIRELESS_AP_MAC}
wireless_ip_addr	${WIRELESS_IP_ADDR}
wireless_mac_addr	${MAC_ADDR}
wireless_handshake_time	${WIRELESS_CONNECTING_TIME}
wireless_ssid	${SSID}
__EOF__
}


function generate_ntp_script {
[ "" == "$1" ] && return
[ "" == "$2" ] && return
cat << __EOF__ > $2
#!/bin/bash
ntpdate -b $1
echo "\$?" > ${BOOT_NTP_SYNC}
date > /tmp/aa
__EOF__
chmod +x $2
}


# Generate 2 variables, and export them:
#    - BOARD_SERIAL_NUMBER    (e.g. `bbg-BBG115081198`)
#    - BOARD_UNIQUE_ID        (e.g. `F99900011`)
#
function generate_id {
	local BEAGLEBONE_ID=$(read_bbb_id)
	local RPI_ID=$(read_rpi2_id)
	local YAC_BSN_FILE="/yac.bsn"
	local YAC_ID_FILE="/yac.id"

	if [ "" != ${BEAGLEBONE_ID} ]; then
		# It's BeagleBone-Black series: BBB/BBG/BBG-Wirelss/IPCS
		#
		export BOARD_SERIAL_NUMBER=${BEAGLEBONE_ID}
		export BOARD_UNIQUE_ID=${BEAGLEBONE_ID}

		[ "" == "$(echo ${BOARD_SERIAL_NUMBER} | grep "^bb.-")" ] || BOARD_SERIAL_NUMBER=$(echo ${BOARD_SERIAL_NUMBER} | sed 's/^bb.\-//g')

		local EMMC_PARTITION1="/dev/mmcblk1p1"
		local EMMC_PARTITION2="/dev/mmcblk1p2"
		local EMMC_ROOT_PARTITION=""
		local EMMC_DIRECTORY="/mnt/emmc"

		if [ -b "${EMMC_PARTITION2}" ]; then
			# Booting from SD card, and BBB/BBG eMMC uses kernel 3.8 with
			# 2 partitions:
			# 	- /dev/mmcblk1p1 (fat32 with boot-loader and MLB)
			# 	- /dev/mmcblk1p2 (ext4 for rootfs)
			#
			EMMC_ROOT_PARTITION=${EMMC_PARTITION2}
			INFO "BeagleBone boots from SD (eMMC has TWO partition)"
		elif [ -b "${EMMC_PARTITION1}" ]; then
			# Booting from SD card, and BBG eMMC uses kernel 4.4.9 with 1 partition:
			# 	- /dev/mmcblk1p1 (ext4 for rootfs, MLB is stored in MBR sector)
			#
			EMMC_ROOT_PARTITION=${EMMC_PARTITION1}
			INFO "BeagleBone boots from SD (eMMC has ONE partition)"
		else
			# Booting from eMMC (so there is no /dev/mmcblk1)
			#
			INFO "BeagleBone boots from eMMC"
		fi
		if [ "" != "${EMMC_ROOT_PARTITION}" ]; then
			# Booting from SD card
			#
			mkdir -p ${EMMC_DIRECTORY} 2>&1 > /dev/null
			mount -t ext4 ${EMMC_ROOT_PARTITION} ${EMMC_DIRECTORY} 2>&1 > /dev/null
			[ -f "${EMMC_DIRECTORY}${YAC_BSN_FILE}" ] && BOARD_SERIAL_NUMBER=$(cat "${EMMC_DIRECTORY}${YAC_BSN_FILE}")
			[ -f "${EMMC_DIRECTORY}${YAC_ID_FILE}" ]  && BOARD_UNIQUE_ID=$(cat "${EMMC_DIRECTORY}${YAC_ID_FILE}")
			[ -f "${EMMC_DIRECTORY}/boot/uEnv.txt" ] && INFO "eMMC kernel: $(YELLOW $(cat ${EMMC_DIRECTORY}/boot/uEnv.txt  | grep "^uname_r" | awk -F'=' '{print $2}'))"
		else
			# Booting from eMMC
			#
			[ -f "${YAC_ID_FILE}" ] && BOARD_UNIQUE_ID=$(cat "${YAC_ID_FILE}")

		fi
	elif [ "" != ${RPI_ID} ]; then
		# It's RPi2/3, boots from SD card
		#
		export BOARD_SERIAL_NUMBER=${RPI_ID}
		export BOARD_UNIQUE_ID=${RPI_ID}
		[ -f "${YAC_ID_FILE}" ] && BOARD_UNIQUE_ID=$(cat "${YAC_ID_FILE}")
	else
		export BOARD_SERIAL_NUMBER=$(generate_unique_id "devboard")
		export BOARD_UNIQUE_ID=${BOARD_SERIAL_NUMBER}
	fi

	[ "" == "${BOARD_UNIQUE_ID}" ] && BOARD_UNIQUE_ID="yac-$(ifconfig eth0 | head -n1 | awk '{print $5}' | tr '[:upper:]' '[:lower:]' | sed 's/\://g')"
	[ "" == "${BOARD_SERIAL_NUMBER}" ] && BOARD_SERIAL_NUMBER=${BOARD_UNIQUE_ID}
}

function update_system_id {
	generate_id
	INFO "METADATA: kernel                = $(YELLOW $(uname -r))"
	INFO "METADATA: distribution          = $(YELLOW $(lsb_release -a 2>/dev/null | grep "Description" | awk -F':' '{print $2}' | sed 's/\t//g'))"
	INFO "METADATA: BOARD_UNIQUE_ID       = $(YELLOW ${BOARD_UNIQUE_ID})"
	INFO "METADATA: BOARD_SERIAL_NUMBER   = $(YELLOW ${BOARD_SERIAL_NUMBER})"
	INFO "METADATA: BOARD_BASE_VERSION    = $(YELLOW ${BOARD_BASE_VERSION})"
	INFO "METADATA: BOARD_PROFILE         = $(YELLOW ${BOARD_PROFILE})"
	INFO "METADATA: BOARD_PROFILE_VERSION = $(YELLOW ${BOARD_PROFILE_VERSION})"
	hostname ${BOARD_UNIQUE_ID}
	sed -i "s/^127\.0\.1\.1.*/127\.0\.1\.1\t$(hostname)\ $(hostname).localdomain/g" /etc/hosts
}

function notify_cloud {
	local TMP=$(mktemp /tmp/XXXXXX)
	jo -p ttt=$(jo $(cat /tmp/ttt_system | tr '\t' '=' | tr '\n' ' ')) > ${TMP}
	cat ${TMP}
	RUN_CMD_STREAMING \
		http \
			--verbose \
			--ignore-stdin \
			https://registry.t2t.io/api/v1/update-node/${BOARD_PROFILE}/${BOARD_UNIQUE_ID} \
			metadata:=@${TMP}
	INFO "successfully https://registry.t2t.io/api/v1/update-node/${BOARD_PROFILE}/${BOARD_UNIQUE_ID}"
	rm -f ${TMP}
}

function generate_sys_info_and_notify_cloud {
	export BOARD_NAME="$(uname -n)"
	export MAC_ADDR=$(ifconfig ${WIRELESS_IF} | grep HWaddr | grep ${WIRELESS_IF} | sed 's/.*HWaddr //g')

	generate_ttt_system

	if [ "true" == "${WIRELESS_CONNECTED}" ]; then
		if [ "99" == "${WIRELESS_CONNECTIVITY}" ]; then
			notify_cloud &
		else
			ERR "connect to access-point but not connect to Internet"
		fi
	else
		ERR "failed to connect to any access-point"
	fi
}


function run_time_daemon_and_restore {
	local TIMESTAMP_LOGGING="${YAC_LIB_DIR}/timestamp_logging.py"
	local TIMESTAMP_DIR="${YS_DIR}/share/timestamp"
	local TIMESTAMP_LOG="${PROFILE_LOG_SYS_DIR}/timestamp_daemon.log"
	local RESULT=""
	mkdir -p ${TIMESTAMP_DIR}

	# Restore timestamp from local disk.
	#
	if [ -f "${SOFT_REBOOT_TAGFILE}" ]; then
		INFO "detect soft reboot, ignore timestamp restore => ${SOFT_REBOOT_TAGFILE} ($(cat ${SOFT_REBOOT_TAGFILE}))"
		rm -f ${SOFT_REBOOT_TAGFILE}
	else
		INFO "boot: before restore => $(date '+%Y/%m/%d %H:%M:%S')" | tee -a ${TIMESTAMP_LOG}
		${TIMESTAMP_LOGGING} -v -d ${TIMESTAMP_DIR} restore
		RESULT=$?
		[ "0" == "${RESULT}" ] && INFO "successfully restore timestamp from local storage" || INFO "failed to restore timestamp: ${RESULT}"
		INFO "boot: after restore => $(date '+%Y/%m/%d %H:%M:%S')" | tee -a ${TIMESTAMP_LOG}
	fi

	# Cleanup old timestamp logging directory.
	# 
	local TMP=$(mktemp /tmp/XXXXXX)
	find /opt/ys/share/timestamp -maxdepth 1 -mindepth 1 -type d | sort > ${TMP}
	if [ "$(cat ${TMP} | wc -l)" -gt "6" ]; then
		local DIR=$(cat ${TMP} | head -n1)
		[ "" != "${DIR}" ] && [ "/" != "${DIR}" ] && INFO "cleanup old timestamp logging directory: $(LIGHT_GREEN ${DIR})" && rm -rf ${DIR}
	fi
	rm -f ${TMP}

	# Startup the timestamp logging daemon, which periodically writes UTC
	# timestamp (in seconds) into disk.
	#
	INFO "starting timestamp logging daemon"
	nohup ${TIMESTAMP_LOGGING} -v -i 300 -d ${TIMESTAMP_DIR} daemon >> ${TIMESTAMP_LOG} 2>&1&
}


function synchronize_time {
	[ "emmc" == "${YAPPS_SYS_RESTORE_SYSTEM_TIME_WITH_SOURCE}" ] && return

	if [ "ntp" == "${YAPPS_SYS_RESTORE_SYSTEM_TIME_WITH_SOURCE}" ]; then
		local SERVER=$(call_func "yac_hook" "get_ntp_server")
		[ "" == "${SERVER}" ] && SERVER="ntp.ubuntu.com"
		INFO "using $(LIGHT_GREEN ${SERVER}) for time synchronization"
		ping -c 1 -W 5 8.8.8.8 > /dev/null 2>&1
		if [ "0" == "$?" ]; then
			generate_ntp_script ${SERVER} /tmp/ntp && /tmp/ntp
		else
			if [ "true" == "${WIRELESS_CONNECTED}" ]; then
				if [ "99" == "${WIRELESS_CONNECTIVITY}" ]; then
					generate_ntp_script ${SERVER} /tmp/ntp && /tmp/ntp
				else
					INFO "but connectivity (${WIRELESS_CONNECTIVITY}) is lower than 99, ignore NTP time synchronization"
					echo "-4" > ${BOOT_NTP_SYNC}
				fi
			else
				INFO "but wireless disconnected, ignore NTP time synchronization"
				echo "-5" > ${BOOT_NTP_SYNC}
			fi
		fi
	elif [ "rtc" == "${YAPPS_SYS_RESTORE_SYSTEM_TIME_WITH_SOURCE}" ]; then
		INFO "time synchronization with RTC is NOT IMPLEMENTED yet!!"
	fi
}


function network_wait {
	local NETWORK_WAIT_TIME=$(call_func "yac_hook" "get_network_wait_time" "${WIRELESS_CONNECTED}" "${WIRELESS_CONNECTIVITY}")
	INFO "network_wait: get_network_wait_time => ${NETWORK_WAIT_TIME}"
	[ "0" == "${NETWORK_WAIT_TIME}" ] && return
	[ "" == "${NETWORK_WAIT_TIME}" ] && return
	INFO "network_wait: sleep for $(LIGHT_GREEN ${NETWORK_WAIT_TIME}) seconds"
	sleep ${NETWORK_WAIT_TIME}
}


function run_init_scripts {
	SCRIPTS=($(find ${PROFILE_CURRENT_DIR}/etc/init.d/ -type f | sort))
	for s in "${SCRIPTS[@]}"; do
		INFO "executing $(LIGHT_GREEN ${BOARD_PROFILE}) / $(BLUE ${BOARD_PROFILE_VERSION}) / $(PURPLE $(basename $s)) ..."
		notify_event "init" "$s" "begin"
		PROFILE_CURRENT_DIR=${PROFILE_CURRENT_DIR} \
			PROFILE_LOG_DIR=${PROFILE_LOG_DIR} \
			IGNORE_NODE_MODUEL_CHECKING=true \
			$s
		notify_event "init" "$s" "end"
	done
}


function notify_event {
	# Invoke hook function from BOARD_SYS_HOOK (YS_DIR/etc/.yac)
	#
	call_func "yac_board_hook" "boot" $@

	# Invoke hook function from PROFILE_SYS_HOOK (/PROFILE/current/etc/.yac)
	#
	call_func "yac_hook" "boot" $@
}


function yac_main {
	source ${YAC_DIR}/externals/bash-utils/system
	INFO "check_prerequisites"
	check_prerequisites

	# Mount all necessary directories from partitions other
	# than boot partition.
	#
	INFO "mount_directories"
	mount_directories

	# Merge system configurations (/opt/yapps-scripts/file/system.conf)
	# and profile system configurations (${PROFILE_CURRENT_DIR}/etc/system.conf)
	# to produce configuration /tmp/yapps.conf.sh, and then load it.
	#
	INFO "load_configurations"
	CONF_VERBOSE=true load_configurations

	# Mount all hook functions for boot process from following
	# 2 sources:
	#   - /opt/ys/etc/.yac
	#   - /PROFILE/current/etc/.yac
	#
	INFO "mount_hooks"
	load_hooks

	# Initiate extra ethernet interfaces.
	#
	INFO "initiate_extra_ethernet_interfaces"
	initiate_extra_ethernet_interfaces

	# Generate all required identities.
	#
	notify_event "begin"
	INFO "update_system_id"
	update_system_id
	notify_event "update_system_id" ${BOARD_UNIQUE_ID}

	# Restore timestamp from local disk cache.
	#
	notify_event "run_time_daemon_and_restore"
	run_time_daemon_and_restore

	# Setup wifi connection.
	#
	INFO "bootup_wireless_adapter"
	notify_event "bootup_wireless_adapter"
	bootup_wireless_adapter
	find_ap_and_connect
	notify_event "wireless" "${WIRELESS_CONNECTED}" "${WIRELESS_CONNECTIVITY}"
	network_wait

	INFO "generate_sys_info_and_notify_cloud"
	notify_event "generate_sys_info_and_notify_cloud"
	generate_sys_info_and_notify_cloud

	INFO "synchronize_time"
	notify_event "synchronize_time"
	synchronize_time

	# Load all crontab tasks from these 3 sources:
	#	- ${YAC_DIR}/files/etc/cron.d/*
	#	- ${YS_DIR}/etc/cron.d/*
	#	- ${PROFILE_CURRENT_DIR}/etc/cron.d/*
	#
	INFO "load_crontab_tasks"
	load_crontab_tasks

	INFO "run_init_scripts"
	run_init_scripts
	notify_event "end"
	INFO "yac_boot.end()"
}

